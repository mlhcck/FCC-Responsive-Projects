<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>

    <nav id="navbar">
        <header id="navbar-header">C# document</header>
        <ul id="nav-ul">
            <li><a href="#A_tour_of_C#_language" class="nav-link">A tour of C# language</a></li>
            <li><a href="#C#_types_and_members" class="nav-link">C# types and members</a></li>
            <li><a href="#C#_program_building_blocks" class="nav-link">C# program building blocks</a></li>
            <li><a href="#C#_major_language_areas" class="nav-link">C# major language areas</a></li>
            <li><a href="#Annotated_C#_strategy" class="nav-link">Annotated C# strategy</a></li>
            <li><a href="#Reference">Reference</a></li>
        </ul>
    </nav>

    <main id="main-doc">
        <!--introduction c# -->
        <section class="main-section" id="A_tour_of_C#_language">
            <header>A tour of C# language</header>
            <p>
                C# (pronounced "See Sharp") is a modern, object-oriented, and type-safe programming language. C# enables
                developers to build many types of secure and robust applications that run in .NET. C# has its roots in
                the C
                family of languages and will be immediately familiar to C, C++, Java, and JavaScript programmers. This
                tour
                provides an overview of the major components of the language in C# 11 and earlier. If you want to
                explore
                the language through interactive examples, try the introduction to C# tutorials.
            </p>
            <p>
                C# is an object-oriented, component-oriented programming language. C# provides language constructs to
                directly support these concepts, making C# a natural language in which to create and use software
                components. Since its origin, C# has added features to support new workloads and emerging software
                design
                practices. At its core, C# is an object-oriented language. You define types and their behavior.
            <header>.NET architecture</header>
            <p>
                C# programs run on .NET, a virtual execution system called the common language runtime (CLR) and a set
                of
                class libraries. The CLR is the implementation by Microsoft of the common language infrastructure (CLI),
                an
                international standard. The CLI is the basis for creating execution and development environments in
                which
                languages and libraries work together seamlessly.
            </p>
            <p>
                Source code written in C# is compiled into an intermediate language (IL) that conforms to the CLI
                specification. The IL code and resources, such as bitmaps and strings, are stored in an assembly,
                typically
                with an extension of .dll. An assembly contains a manifest that provides information about the
                assembly's
                types, version, and culture.
            </p>
            <p>
                When the C# program is executed, the assembly is loaded into the CLR. The CLR performs Just-In-Time
                (JIT)
                compilation to convert the IL code to native machine instructions. The CLR provides other services
                related
                to automatic garbage collection, exception handling, and resource management. Code that's executed by
                the
                CLR is sometimes referred to as "managed code." "Unmanaged code," is compiled into native machine
                language
                that targets a specific platform.
            </p>
            <header>Hello World</header>
            <pre><code>
            using System;

            class Hello
            {
                static void Main()
                {
                    // This line prints "Hello, World" 
                    Console.WriteLine("Hello, World");
                }
            }
        </code>
        </pre>
            <p>
                The "Hello, World" program starts with a using directive that references the System namespace.
                Namespaces
                provide a hierarchical means of organizing C# programs and libraries. Namespaces contain types and other
                namespaces-for example, the System namespace contains a number of types, such as the Console class
                referenced in the program, and many other namespaces, such as IO and Collections. A using directive that
                references a given namespace enables unqualified use of the types that are members of that namespace.
                Because of the using directive, the program can use Console.WriteLine as shorthand for
                System.Console.WriteLine.
            </p>
            <p>
                The line starting with // is a single line comment. C# single line comments start with // continue to
                the
                end of the current line. C# also supports multi-line comments. Multi-line comments start with /* and end
                with */. The output of the program is produced by the WriteLine method of the Console class in the
                System
                namespace. This class is provided by the standard class libraries, which, by default, are automatically
                referenced by the compiler.
            </p>
        </section>

        <!--C# types-->
        <section class="main-section" id="C#_types_and_members">
            <header>C# types and members</header>
            <p>
                As an object-oriented language, C# supports the concepts of encapsulation, inheritance, and
                polymorphism. A
                class may inherit directly from one parent class, and it may implement any number of interfaces. Methods
                that override virtual methods in a parent class require the override keyword as a way to avoid
                accidental
                redefinition. In C#, a struct is like a lightweight class; it's a stack-allocated type that can
                implement
                interfaces but doesn't support inheritance. C# provides record class and record struct types, which are
                types whose purpose is primarily storing data values.
            </p>
            <p>
                All types are initialized through a constructor, a method responsible for initializing an instance. Two
                constructor declarations have unique behavior:
            </p>
            <ul>
                <li>
                    <p>A parameterless constructor, which initializes all fields to their default value.</p>
                </li>
                <li>
                    <p>A primary constructor, which declares the required parameters for an instance of that type.</p>
                </li>
            </ul>

            <header>Classes and objects</header>
            <p>
                Classes are the most fundamental of C#'s types. A class is a data structure that combines state (fields)
                and
                actions (methods and other function members) in a single unit. A class provides a definition for
                instances
                of the class, also known as objects. Classes support inheritance and polymorphism, mechanisms whereby
                derived classes can extend and specialize base classes.
            </p>
            <p>
                New classes are created using class declarations. A class declaration starts with a header. The header
                specifies:
            </p>
            <ul>
                <li>
                    <p>The attributes and modifiers of the class</p>
                </li>
                <li>
                    <p>The name of the class</p>
                </li>
                <li>
                    <p>The base class (when inheriting from a base class)</p>
                </li>
                <li>
                    <p>The interfaces implemented by the class.</p>
                </li>
            </ul>
            <p>
                The following code shows a declaration of a simple class named Point:
            </p>
            <pre><code>
            public class Point
            {
                public int X { get; }
                public int Y { get; }
    
                public Point(int x, int y) => (X, Y) = (x, y);
            }
        </code>
        </pre>
            <p>
                Instances of classes are created using the new operator, which allocates memory for a new instance,
                invokes
                a constructor to initialize the instance, and returns a reference to the instance. The following
                statements
                create two Point objects and store references to those objects in two variables:
            </p>
            <pre><code>
            var p1 = new Point(0, 0);
            var p2 = new Point(10, 20);
        </code>
        </pre>
            <p>
                Instances of classes are created using the new operator, which allocates memory for a new instance,
                invokes
                a constructor to initialize the instance, and returns a reference to the instance. The following
                statements
                create two Point objects and store references to those objects in two variables:
            </p>
            <pre><code>
            var p1 = new Point(0, 0);
            var p2 = new Point(10, 20);
        </code>
        </pre>
            <p>
                Applications or tests for algorithms might need to create multiple Point objects. The following class
                generates a sequence of random points. The number of points is set by the primary constructor parameter.
                The
                primary constructor parameter numberOfPoints is in scope for all members of the class:
            </p>
            <pre><code>
            public class PointFactory(int numberOfPoints)
            {
                public IEnumerable<Point> CreatePoints()
                {           
                    var generator = new Random();
                    for (int i = 0; i < numberOfPoints; i++)
                    {
                        yield return new Point(generator.Next(), generator.Next());
                    }
                }
            }
        </code>
        </pre>
            <p>
                You can use the class as shown in the following code:
            </p>
            <pre><code>
            var factory = new PointFactory(10);
            foreach (var point in factory.CreatePoints())
            {
                Console.WriteLine($"({point.X}, {point.Y})");
            }
        </code>
        </pre>
        </section>

        <!--Csharp blocks-->
        <section class="main-section" id="C#_program_building_blocks">
            <header>C# program building blocks</header>
            <p>
                The types described in the previous article in this Tour of C# series are built by using these building
                blocks:
            </p>
            <ul>
                <li>
                    <p>Members, such as properties, fields, methods, and events.</p>
                </li>
                <li>
                    <p>Expressions</p>
                </li>
                <li>
                    <p>Statements</p>
                </li>
            </ul>

            <header>Members</header>
            <p>
                The members of a class are either static members or instance members. Static members belong to classes,
                and
                instance members belong to objects (instances of classes).
                <br>
                The following list provides an overview of the kinds of members a class can contain.
            </p>
            <ul>
                <li>
                    <p>
                        <bold>Constants</bold>: Constant values associated with the class
                    </p>
                </li>
                <li>
                    <p>
                        <bold>Fields</bold>: Variables that are associated with the class
                    </p>
                </li>
                <li>
                    <p>
                        <bold>Methods</bold>:Actions that can be performed by the class
                    </p>
                </li>
                <li>
                    <p>
                        <bold>Properties</bold>:Actions associated with reading and writing named properties of the
                        class
                    </p>
                </li>
                <li>
                    <p>
                        <bold>Indexers</bold>:Actions associated with indexing instances of the class like an array
                    </p>
                </li>
                <li>
                    <p>
                        <bold>Events</bold>:Notifications that can be generated by the class
                    </p>
                </li>
                <li>
                    <p>
                        <bold>Operators</bold>:Conversions and expression operators supported by the class
                    </p>
                </li>
                <li>
                    <p>
                        <bold>Constructors</bold>:Actions required to initialize instances of the class or the class
                        itself
                    </p>
                </li>
                <li>
                    <p>
                        <bold>Finalizers</bold>:Actions done before instances of the class are permanently discarded
                    </p>
                </li>
                <li>
                    <p>
                        <bold>Types</bold>:Nested types declared by the class
                    </p>
                </li>
            </ul>

            <header>Accessibility</header>
            <p>
                Each member of a class has an associated accessibility, which controls the regions of program text that
                can
                access the member. There are six possible forms of accessibility. The access modifiers are summarized
                below.
            </p>
            <ul>
                <li>
                    <p>
                        <bol>public</bol>: Access isn't limited.
                    </p>
                </li>
                <li>
                    <p>
                        <bold>private</bold>: Access is limited to this class.
                    </p>
                </li>
                <li>
                    <p>
                        <bold>protected</bold>: Access is limited to this class or classes derived from this class.
                    </p>
                </li>
                <li>
                    <p>
                        <bold>internal</bold>: Access is limited to the current assembly (.exe or .dll).
                    </p>
                </li>
                <li>
                    <p>
                        <bold>protected internal</bold>: Access is limited to this class, classes derived from this
                        class,
                        or classes within the same assembly.
                    </p>
                </li>
                <li>
                    <p>
                        <bold>private protected</bold>: Access is limited to this class or classes derived from this
                        type
                        within the same assembly.
                    </p>
                </li>
            </ul>

            <header>Field</header>
            <p>
                A field is a variable that is associated with a class or with an instance of a class.
                <br>
                A field declared with the static modifier defines a static field. A static field identifies exactly one
                storage location. No matter how many instances of a class are created, there's only ever one copy of a
                static field.
                <br>
                A field declared without the static modifier defines an instance field. Every instance of a class
                contains a
                separate copy of all the instance fields of that class.
                <br>
                In the following example, each instance of the Color class has a separate copy of the R, G, and B
                instance
                fields, but there's only one copy of the Black, White, Red, Green, and Blue static fields:
            </p>
            <pre><code>
            public class Color
            {
                public static readonly Color Black = new(0, 0, 0);
                public static readonly Color White = new(255, 255, 255);
                public static readonly Color Red = new(255, 0, 0);
                public static readonly Color Green = new(0, 255, 0);
                public static readonly Color Blue = new(0, 0, 255);
    
                public byte R;
                public byte G;
                public byte B;

                public Color(byte r, byte g, byte b)
                {
                    R = r;
                    G = g;
                    B = b;
                }
            }
        </code>
        </pre>
            <p>
                As shown in the previous example, read-only fields may be declared with a readonly modifier. Assignment
                to a
                read-only field can only occur as part of the field's declaration or in a constructor in the same class.
            </p>
        </section>

        <!--Csharp Arrays-->
        <section class="main-section" id="C#_major_language_areas">
            <header>C# major language areas</header>
            <header>Arrays, collections, and LINQ</header>
            <p>
                C# and .NET provide many different collection types. Arrays have syntax defined by the language. Generic
                collection types are listed in the "System.Collections.Generic" namespace. Specialized
                collections include "System.Span&lt;T&gt;" for accessing continuous memory on the stack frame,
                and "System.Memory&lt;T&gt;" for accessing continuous memory on the managed heap. All
                collections, including arrays, "Span&lt;T&gt;", and "Memory&lt;T&gt;", share a
                unifying principle for iteration. You use the "System.Collections.Generic.IEnumerable&lt;T&gt;"
                interface. This unifying principle means that any of the collection types can be used with LINQ queries
                or
                other algorithms. You write methods using "IEnumerable&lt;T&gt;" and those algorithms work with
                any collection.
            </p>
            <header>Arrays</header>
            <p>
                An array is a data structure that contains a number of variables that are accessed through computed
                indices. The variables contained in an array, also called the elements of the array, are all of the same
                type. This type is called the element type of the array.
            </p>
            <p>
                Array types are reference types, and the declaration of an array variable simply sets aside space for a
                reference to an array instance. Actual array instances are created dynamically at run time using the new
                operator. The new operation specifies the length of the new array instance, which is then fixed for the
                lifetime of the instance. The indices of the elements of an array range from 0 to Length - 1. The new
                operator automatically initializes the elements of an array to their default value, which, for example,
                is zero for all numeric types and null for all reference types.
                <br>
                The following example creates an array of int elements, initializes the array, and prints the contents
                of the array.
            </p>
            <pre><code>
            int[] a = new int[10];
            for (int i = 0; i < a.Length; i++)
            {
                a[i] = i * i;
            }
            for (int i = 0; i < a.Length; i++)
            {
                Console.WriteLine($"a[{i}] = {a[i]}");
            }
        </code>
        </pre>
            <p>
                This example creates and operates on a single-dimensional array. C# also supports multi-dimensional
                arrays. The number of dimensions of an array type, also known as the rank of the array type, is one plus
                the number of commas between the square brackets of the array type. The following example allocates a
                single-dimensional, a two-dimensional, and a three-dimensional array, respectively.
            </p>
            <pre><code>
            int[] a1 = new int[10];
            int[,] a2 = new int[10, 5];
            int[,,] a3 = new int[10, 5, 2];
        </code>
        </pre>
            <p>
                The a1 array contains 10 elements, the a2 array contains 50 (10 x 5) elements, and the a3 array contains
                100 (10 x 5 x 2) elements. The element type of an array can be any type, including an array type. An
                array with elements of an array type is sometimes called a jagged array because the lengths of the
                element arrays don't all have to be the same. The following example allocates an array of arrays of int:
            </p>
            <pre><code>
            int[][] a = new int[3][];
            a[0] = new int[10];
            a[1] = new int[5];
            a[2] = new int[20];
        </code>
        </pre>
            <p>
                The first line creates an array with three elements, each of type int[] and each with an initial value
                of null. The next lines then initialize the three elements with references to individual array instances
                of varying lengths.
                <br>
                The new operator permits the initial values of the array elements to be specified using an array
                initializer, which is a list of expressions written between the delimiters { and }. The following
                example allocates and initializes an int[] with three elements.
            </p>
            <pre><code>
            int[] a = new int[] { 1, 2, 3 };
        </code>
        </pre>
            <p>The length of the array is inferred from the number of expressions between { and }. Array initialization
                can be shortened further such that the array type doesn't have to be restated.</p>
            <pre><code>
            int[] a = { 1, 2, 3 };
        </code>
        </pre>
            <p>Both of the previous examples are equivalent to the following code:</p>
            <pre><code>
            int[] t = new int[3];
            t[0] = 1;
            t[1] = 2;
            t[2] = 3;
            int[] a = t;
        </code>
        </pre>
        </section>

        <!--Csharp strategy-->
        <section class="main-section" id="Annotated_C#_strategy">
            <header>Annotated C# strategy</header>
            <p>
                We will keep evolving C# to meet the changing needs of developers and remain a state-of-the-art
                programming language. We will innovate eagerly and broadly in collaboration with the teams responsible
                for .NET libraries, developer tools, and workload support, while being careful to stay within the spirit
                of the language. Recognizing the diversity of domains where C# is being used, we will prefer language
                and performance improvements that benefit all or most developers and maintain a high commitment to
                backwards compatibility. We will continue to empower the broader .NET ecosystem and grow its role in
                C#’s future, while maintaining stewardship of design decisions.
            </p>
            <header>How strategy guides C#</header>
            <p>
                The C# strategy guides our decisions about C# evolution, and these annotations provide insight into how
                we think about key statements.
            </p>
            <blockquote>
                "we will innovate eagerly and broadly"
            </blockquote>
            <p>
                The C# community continues to grow, and the C# language continues to evolve to meet the community's
                needs and expectations. We draw inspiration from a variety of sources to select features that benefit a
                large segment of C# developers, and that provide consistent improvements in productivity, readability,
                and performance.
            </p>
            <blockquote>
                "being careful to stay within the spirit of the language"
            </blockquote>
            <p>
                We evaluate new ideas in the spirit and history of the C# language. We prioritize innovations that make
                sense to the majority of existing C# developers.
            </p>
            <blockquote>
                "improvements that benefit all or most developers"
            </blockquote>
            <p>
                Developers use C# in all .NET workloads, such as web front and back ends, cloud native development,
                desktop development and building cross platform applications. We focus on new features that have the
                most impact either directly, or by empowering improvements to common libraries. Language feature
                development includes integration into our developer tools and learning resources.
            </p>
            <blockquote>
                "high commitment to backwards compatibility"
            </blockquote>
        </section>

        <section class="main-section" id="Reference">
            <header>Reference</header>
            <ul>
                <li><p class="last-p">All the documentation in this page is taken from <a
                    href="https://learn.microsoft.com/en-us/dotnet/csharp/">C# documentation</a>.</p></li>
            </ul>
        
        </section>
    </main>
</body>

</html>